The flag is xor with a keystream generated by a 4096-bit XorShift+ PRNG.
Initial state of the PRNG is known, but the bits of interest are very far (on the order of `2^64`)
into the stream and cannot be trivially computed.

How XorShift+ works
===================

	def randgen():
		global s,p
		a = 3
		b = 13
		c = 37
		s0 = s[p]
		p = (p + 1) & 63
		s1 = s[p]
		res = (s0 + s1) & ((1<<64)-1)
		s1 ^= (s1 << a) & ((1<<64)-1)
		s[p] = (s1 ^ s0 ^ (s1 >> b) ^ (s0 >> c))	& ((1<<64)-1)
		return res

Note that addition mod `2^64` is only done for outputs and the state `s[0:64]` is updated
linearly. Furthermore, the changes made to `s` by 64 consequtive `randgen()` calls can be
defined by a multiplication with a single 4096x4096 matrix over `GF(2)`.

Let `x_at(n)` be the value of `s1` in `randgen()` after `n` calls.
Then we can define `randgen_at(n)` like so:

	def randgen_at(pos): # value of randgen() after n calls
		if pos == 0:
			return 1
		elif pos < 64:
			return (pos+1 + x_at(pos-1))
		elif pos == 64:
			return x_at(pos-1)
		else:
			return (x_at(pos-1) + x_at(pos-64)) & ((1<<64)-1)

Now we only need to implement `x_at(n)`.

Evaluating `x_at(n)` at arbitrary `n`
=====================================

An intuitive way to do this would be to calculate internal state `s` by raising the matrix
mentioned above to `floor(n/64)`. This will take `O(log n * L^3)` time, which is too slow for
L = 4096.

Instead we will model `bit_at(n, k) = x_at(n)>>k&1` as a linear recurrence (degree can be 4096 at most),
and calculate each bit in `O(log n * L^2)` time.

To find the linear recurrences we simply dump `bit_at(n, k)` for n < 12000 (see `gen_bitseqs.py`) and
feed each bitstream to Berlekamp-Massey's algorithm (implemented in `lrsynth.cpp`).

Once we have a recurrence of the form `S(i) = k_1*S(i+1) + k_2*S(i+2) ... + k_L*S(i+L)` we use binary
lifting to efficiently calculate `S(i) = k_1'*S(i+n) + ... + k_L'*S(i+L+n)` for arbitrary n.
Finally, we plug in known values `S(1)`, `S(2)`, ... `S(L)` and calculate `S(n)`. We repeat this
for each bit and end up with `x_at(n)`.

See `src/main.rs` for the implementation. Note that the position `n` can be greater than `2^64`.
